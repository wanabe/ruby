use crate::asm::*;
use crate::asm::riscv64::*;
use crate::codegen::CodePtr;
use crate::backend::ir::*;

// Use the x86 register type for this platform
pub type Reg = Riscv64Reg;

// Callee-saved registers
pub const _CFP: Opnd = Opnd::Reg(S2_REG);
pub const _EC: Opnd = Opnd::Reg(S3_REG);
pub const _SP: Opnd = Opnd::Reg(S4_REG);

// C argument registers on this platform
pub const _C_ARG_OPNDS: [Opnd; 6] = [
    Opnd::Reg(A0_REG),
    Opnd::Reg(A1_REG),
    Opnd::Reg(A2_REG),
    Opnd::Reg(A3_REG),
    Opnd::Reg(A4_REG),
    Opnd::Reg(A5_REG)
];

// C return value register on this platform
pub const C_RET_REG: Reg = RA_REG;
pub const _C_RET_OPND: Opnd = Opnd::Reg(RA_REG);

impl CodeBlock {
    // The maximum number of bytes that can be generated by emit_jmp_ptr.
    // TODO: return correct value
    pub fn jmp_ptr_bytes(&self) -> usize { 20 }
}

/// List of registers that can be used for stack temps.
pub static TEMP_REGS: [Reg; 5] = [A0_REG, A1_REG, A2_REG, A3_REG, A4_REG];

impl Assembler
{
    // A special scratch register for intermediate processing.
    // This register is caller-saved (so we don't have to save it before using it)
    pub const SCRATCH_REG: Reg = A7_REG;

    /// Get the list of registers from which we can allocate on this platform
    pub fn get_alloc_regs() -> Vec<Reg>
    {
        vec![
            A2_REG,
            A3_REG,
            A4_REG,
        ]
    }

    /// Optimize and compile the stored instructions
    pub fn compile_with_regs(self, _cb: &mut CodeBlock, _ocb: Option<&mut OutlinedCb>, _regs: Vec<Reg>) -> Option<(CodePtr, Vec<u32>)> {
        None
    }
}
